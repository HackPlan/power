// Generated by CoffeeScript 1.6.2
(function() {
  var LineBuffer, Stream, async, exec, execFile, fs, getUserLocale, getUserShell, loginExec, makeTemporaryFilename, parseEnv, path, quote, readAndUnlink,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  fs = require("fs");

  path = require("path");

  async = require("async");

  execFile = require("child_process").execFile;

  Stream = require("stream").Stream;

  exports.LineBuffer = LineBuffer = (function(_super) {
    __extends(LineBuffer, _super);

    function LineBuffer(stream) {
      var self;

      this.stream = stream;
      this.readable = true;
      this._buffer = "";
      self = this;
      this.stream.on('data', function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return self.write.apply(self, args);
      });
      this.stream.on('end', function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return self.end.apply(self, args);
      });
    }

    LineBuffer.prototype.write = function(chunk) {
      var index, line, _results;

      this._buffer += chunk;
      _results = [];
      while ((index = this._buffer.indexOf("\n")) !== -1) {
        line = this._buffer.slice(0, index);
        this._buffer = this._buffer.slice(index + 1, this._buffer.length);
        _results.push(this.emit('data', line));
      }
      return _results;
    };

    LineBuffer.prototype.end = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length > 0) {
        this.write.apply(this, args);
      }
      if (this._buffer.length) {
        this.emit('data', this._buffer);
      }
      return this.emit('end');
    };

    return LineBuffer;

  })(Stream);

  exports.bufferLines = function(stream, callback) {
    var buffer;

    buffer = new LineBuffer(stream);
    buffer.on("data", callback);
    return buffer;
  };

  exports.mkdirp = function(dirname, callback) {
    var p;

    return fs.lstat((p = path.normalize(dirname)), function(err, stats) {
      var paths;

      if (err) {
        paths = [p].concat((function() {
          var _results;

          _results = [];
          while (p !== "/" && p !== ".") {
            _results.push(p = path.dirname(p));
          }
          return _results;
        })());
        return async.forEachSeries(paths.reverse(), function(p, next) {
          return fs.exists(p, function(exists) {
            if (exists) {
              return next();
            } else {
              return fs.mkdir(p, 0x1ed, function(err) {
                if (err) {
                  return callback(err);
                } else {
                  return next();
                }
              });
            }
          });
        }, callback);
      } else if (stats.isDirectory()) {
        return callback();
      } else {
        return callback("file exists");
      }
    });
  };

  exports.chown = function(path, owner, callback) {
    var error;

    error = "";
    return exec(["chown", owner, path], function(err, stdout, stderr) {
      if (err) {
        return callback(err, stderr);
      } else {
        return callback(null);
      }
    });
  };

  exports.pause = function(stream) {
    var onClose, onData, onEnd, queue, removeListeners;

    queue = [];
    onData = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return queue.push(['data'].concat(__slice.call(args)));
    };
    onEnd = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return queue.push(['end'].concat(__slice.call(args)));
    };
    onClose = function() {
      return removeListeners();
    };
    removeListeners = function() {
      stream.removeListener('data', onData);
      stream.removeListener('end', onEnd);
      return stream.removeListener('close', onClose);
    };
    stream.on('data', onData);
    stream.on('end', onEnd);
    stream.on('close', onClose);
    return function() {
      var args, _i, _len, _results;

      removeListeners();
      _results = [];
      for (_i = 0, _len = queue.length; _i < _len; _i++) {
        args = queue[_i];
        _results.push(stream.emit.apply(stream, args));
      }
      return _results;
    };
  };

  exports.sourceScriptEnv = function(script, env, options, callback) {
    var command, cwd, filename, _ref;

    if (options.call) {
      callback = options;
      options = {};
    } else {
      if (options == null) {
        options = {};
      }
    }
    cwd = path.dirname(script);
    filename = makeTemporaryFilename();
    command = "" + ((_ref = options.before) != null ? _ref : "true") + " &&\nsource " + (quote(script)) + " > /dev/null &&\nenv > " + (quote(filename));
    return exec(["bash", "-c", command], {
      cwd: cwd,
      env: env
    }, function(err, stdout, stderr) {
      if (err) {
        err.message = "'" + script + "' failed to load:\n" + command;
        err.stdout = stdout;
        err.stderr = stderr;
        return callback(err);
      } else {
        return readAndUnlink(filename, function(err, result) {
          if (err) {
            return callback(err);
          } else {
            return callback(null, parseEnv(result));
          }
        });
      }
    });
  };

  exports.getUserEnv = function(callback, defaultEncoding) {
    var filename;

    if (defaultEncoding == null) {
      defaultEncoding = "UTF-8";
    }
    filename = makeTemporaryFilename();
    return loginExec("exec env > " + (quote(filename)), function(err) {
      if (err) {
        return callback(err);
      } else {
        return readAndUnlink(filename, function(err, result) {
          if (err) {
            return callback(err);
          } else {
            return getUserLocale(function(locale) {
              var env, _ref;

              env = parseEnv(result);
              if ((_ref = env.LANG) == null) {
                env.LANG = "" + locale + "." + defaultEncoding;
              }
              return callback(null, env);
            });
          }
        });
      }
    });
  };

  exec = function(command, options, callback) {
    if (callback == null) {
      callback = options;
      options = {};
    }
    return execFile("/usr/bin/env", command, options, callback);
  };

  quote = function(string) {
    return "'" + string.replace(/\'/g, "'\\''") + "'";
  };

  makeTemporaryFilename = function() {
    var filename, random, timestamp, tmpdir, _ref;

    tmpdir = (_ref = process.env.TMPDIR) != null ? _ref : "/tmp";
    timestamp = new Date().getTime();
    random = parseInt(Math.random() * Math.pow(2, 16));
    filename = "power." + process.pid + "." + timestamp + "." + random;
    return path.join(tmpdir, filename);
  };

  readAndUnlink = function(filename, callback) {
    return fs.readFile(filename, "utf8", function(err, contents) {
      if (err) {
        return callback(err);
      } else {
        return fs.unlink(filename, function(err) {
          if (err) {
            return callback(err);
          } else {
            return callback(null, contents);
          }
        });
      }
    });
  };

  loginExec = function(command, callback) {
    return getUserShell(function(shell) {
      var login;

      login = ["login", "-qf", process.env.LOGNAME, shell];
      return exec(__slice.call(login).concat(["-i"], ["-c"], [command]), function(err, stdout, stderr) {
        if (err) {
          return exec(__slice.call(login).concat(["-c"], [command]), callback);
        } else {
          return callback(null, stdout, stderr);
        }
      });
    });
  };

  getUserShell = function(callback) {
    var command;

    command = ["dscl", ".", "-read", "/Users/" + process.env.LOGNAME, "UserShell"];
    return exec(command, function(err, stdout, stderr) {
      var match, matches, shell;

      if (err) {
        return callback(process.env.SHELL);
      } else {
        if (matches = stdout.trim().match(/^UserShell: (.+)$/)) {
          match = matches[0], shell = matches[1];
          return callback(shell);
        } else {
          return callback(process.env.SHELL);
        }
      }
    });
  };

  getUserLocale = function(callback) {
    return exec(["defaults", "read", "-g", "AppleLocale"], function(err, stdout, stderr) {
      var locale, _ref;

      locale = (_ref = stdout != null ? stdout.trim() : void 0) != null ? _ref : "";
      if (!locale.match(/^\w+$/)) {
        locale = "en_US";
      }
      return callback(locale);
    });
  };

  parseEnv = function(stdout) {
    var env, line, match, matches, name, value, _i, _len, _ref;

    env = {};
    _ref = stdout.split("\n");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (matches = line.match(/([^=]+)=(.+)/)) {
        match = matches[0], name = matches[1], value = matches[2];
        env[name] = value;
      }
    }
    return env;
  };

}).call(this);
